name: "Build macOS tools"

on:
  workflow_dispatch:
  release:
    types: [created]
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-tbc-tools:
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest, macos-15-intel]
        include:
          - os: macos-latest
            arch: arm64
          - os: macos-15-intel
            arch: x86_64

    name: Build tbc-tools (${{ matrix.arch }})
    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: true

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
        env:
          NIX_FIRST_BUILD_UID: 401
          NIX_BUILD_USER_NAME_TEMPLATE: _nixbld_ci_%d

      - name: Build with Nix
        run: |
          nix build .#
          mkdir -p dist/bin
          
          # Copy wrapped GUI binary (avoid Nix wrapper with hardcoded paths)
          cp result/bin/ld-analyse.app/Contents/MacOS/.ld-analyse-wrapped dist/bin/ld-analyse
          chmod +x dist/bin/ld-analyse
          
          # Copy wrapped CLI tools (strip leading dot and -wrapped suffix)
          for wrapped in result/bin/.*-wrapped; do
            [ -f "$wrapped" ] || continue
            base="$(basename "$wrapped")"
            base="${base#.}"
            base="${base%-wrapped}"
            cp "$wrapped" "dist/bin/$base"
            chmod +x "dist/bin/$base"
          done

      - name: Get version info
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "version=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          else
            echo "version=$(git describe --tags --always --dirty)" >> $GITHUB_OUTPUT
          fi

      - name: Create app bundle structure
        run: |
          mkdir -p dist/tbc-tools.app/Contents/{Resources,MacOS,Frameworks,PlugIns}

          # Create Info.plist with dynamic version
          cat > dist/tbc-tools.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>TBC Tools</string>
              <key>CFBundleExecutable</key>
              <string>ld-analyse</string>
              <key>CFBundleIconFile</key>
              <string>tbc-tools.icns</string>
              <key>CFBundleIdentifier</key>
              <string>dev.domesday.tbc-tools</string>
              <key>CFBundleInfoDictionaryVersion</key>
              <string>6.0</string>
              <key>CFBundleName</key>
              <string>tbc-tools</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ steps.version.outputs.version }}</string>
              <key>CFBundleVersion</key>
              <string>${{ steps.version.outputs.version }}</string>
              <key>NSHighResolutionCapable</key>
              <true/>
              <key>NSRequiresAquaSystemAppearance</key>
              <false/>
          </dict>
          </plist>
          EOF

          # Copy binaries to MacOS folder
          cp -r dist/bin/* dist/tbc-tools.app/Contents/MacOS/
          
          # Copy scripts if they exist
          if [ -d "scripts" ]; then
            find scripts -maxdepth 1 -perm +111 -type f -exec cp {} dist/tbc-tools.app/Contents/MacOS/ \; 2>/dev/null || true
          fi
      - name: Bundle Python deps (numpy)
        run: |
          APP="dist/tbc-tools.app"
          PY_DIR="$APP/Contents/Resources/python"
          mkdir -p "$PY_DIR"
          PYTHON_BIN="/usr/bin/python3"
          if [ ! -x "$PYTHON_BIN" ]; then
            PYTHON_BIN="$(command -v python3 || true)"
          fi
          if [ -z "$PYTHON_BIN" ]; then
            echo "No python3 found for numpy install"
            exit 1
          fi
          "$PYTHON_BIN" -m pip install --target "$PY_DIR" numpy
          
          SCRIPT="$APP/Contents/MacOS/test-decode-pretbc"
          if [ -f "$SCRIPT" ] && [ ! -f "$SCRIPT.py" ]; then
            mv "$SCRIPT" "$SCRIPT.py"
            cat > "$SCRIPT" << 'EOF'
          #!/bin/sh
          DIR="$(cd "$(dirname "$0")" && pwd)"
          PY_DIR="$DIR/../Resources/python"
          export PYTHONPATH="$PY_DIR${PYTHONPATH:+:$PYTHONPATH}"
          if [ -x /usr/bin/python3 ]; then
            PY="/usr/bin/python3"
          else
            PY="$(command -v python3)"
          fi
          exec "$PY" "$DIR/test-decode-pretbc.py" "$@"
          EOF
            chmod +x "$SCRIPT"
          fi

      - name: Create app icon
        run: |
          ICONSET_ROOT="$(mktemp -d)"
          ICONSET="$ICONSET_ROOT/ld-analyse.iconset"
          mkdir -p "$ICONSET"
          cp src/ld-analyse/Graphics/16-analyse.png "$ICONSET/icon_16x16.png"
          cp src/ld-analyse/Graphics/32-analyse.png "$ICONSET/icon_16x16@2x.png"
          cp src/ld-analyse/Graphics/32-analyse.png "$ICONSET/icon_32x32.png"
          cp src/ld-analyse/Graphics/64-analyse.png "$ICONSET/icon_32x32@2x.png"
          cp src/ld-analyse/Graphics/128-analyse.png "$ICONSET/icon_128x128.png"
          cp src/ld-analyse/Graphics/256-analyse.png "$ICONSET/icon_128x128@2x.png"
          cp src/ld-analyse/Graphics/256-analyse.png "$ICONSET/icon_256x256.png"
          if command -v sips >/dev/null 2>&1; then
            sips -z 512 512 src/ld-analyse/Graphics/256-analyse.png --out "$ICONSET/icon_256x256@2x.png"
            sips -z 512 512 src/ld-analyse/Graphics/256-analyse.png --out "$ICONSET/icon_512x512.png"
            sips -z 1024 1024 src/ld-analyse/Graphics/256-analyse.png --out "$ICONSET/icon_512x512@2x.png"
          else
            cp src/ld-analyse/Graphics/256-analyse.png "$ICONSET/icon_256x256@2x.png"
            cp src/ld-analyse/Graphics/256-analyse.png "$ICONSET/icon_512x512.png"
          fi
          iconutil -c icns "$ICONSET" -o dist/tbc-tools.app/Contents/Resources/tbc-tools.icns

      - name: Bundle Qt plugins and qt.conf
        run: |
          mkdir -p dist/tbc-tools.app/Contents/PlugIns
          
          # Extract plugin paths from Nix wrapper and copy plugins
          PLUGIN_PATHS=$(strings -n 8 result/bin/ld-analyse.app/Contents/MacOS/ld-analyse | grep "/qt-6/plugins" | sort -u || true)
          for p in $PLUGIN_PATHS; do
            if [ -d "$p" ]; then
              rsync -a "$p/" dist/tbc-tools.app/Contents/PlugIns/
            fi
          done
          
          cat > dist/tbc-tools.app/Contents/Resources/qt.conf << 'EOF'
          [Paths]
          Plugins = PlugIns
          EOF

      - name: Bundle dependencies
        shell: bash
        run: |
          APP="dist/tbc-tools.app"
          FW_DIR="$APP/Contents/Frameworks"
          PLUGINS_DIR="$APP/Contents/PlugIns"

          mkdir -p "$FW_DIR" "$PLUGINS_DIR"
          chmod -R u+w "$APP/Contents" 2>/dev/null || true

          is_macho() {
            file "$1" 2>/dev/null | grep -q "Mach-O"
          }

          newref_for_dep() {
            local dep="$1"
            if [[ "$dep" == *".framework/"* ]]; then
              local framework_root
              framework_root=$(echo "$dep" | sed -E "s|(.*\\.framework)/.*|\\1|")
              local framework_name
              framework_name=$(basename "$framework_root")
              local version
              version=$(echo "$dep" | sed -E "s|.*\\.framework/Versions/([^/]+)/.*|\\1|")
              local bin_name
              bin_name=$(basename "$dep")
              echo "@rpath/$framework_name/Versions/$version/$bin_name"
            else
              local base
              base=$(basename "$dep")
              echo "@rpath/$base"
            fi
          }

          copy_dep() {
            local dep="$1"
            if [[ "$dep" == *".framework/"* ]]; then
              local framework_root
              framework_root=$(echo "$dep" | sed -E "s|(.*\\.framework)/.*|\\1|")
              local framework_name
              framework_name=$(basename "$framework_root")
              local version
              version=$(echo "$dep" | sed -E "s|.*\\.framework/Versions/([^/]+)/.*|\\1|")
              local bin_name
              bin_name=$(basename "$dep")
              local target="$FW_DIR/$framework_name/Versions/$version/$bin_name"

              if [ ! -f "$target" ]; then
                rsync -a "$framework_root" "$FW_DIR/"
                chmod -R u+w "$FW_DIR/$framework_name" || true
              fi

              install_name_tool -id "@rpath/$framework_name/Versions/$version/$bin_name" "$target" 2>/dev/null || true
              echo "$target"
            else
              local base
              base=$(basename "$dep")
              local target="$FW_DIR/$base"
              if [ ! -f "$target" ]; then
                cp "$dep" "$target" 2>/dev/null || true
                chmod u+w "$target" 2>/dev/null || true
              fi
              install_name_tool -id "@rpath/$base" "$target" 2>/dev/null || true
              echo "$target"
            fi
          }

          add_rpaths() {
            local file="$1"
            install_name_tool -add_rpath "@executable_path/../Frameworks" "$file" 2>/dev/null || true
            install_name_tool -add_rpath "@loader_path/../Frameworks" "$file" 2>/dev/null || true
            install_name_tool -add_rpath "@loader_path/../../Frameworks" "$file" 2>/dev/null || true
          }

          delete_nix_rpaths() {
            local file="$1"
            local rpaths
            rpaths=$(otool -l "$file" 2>/dev/null | awk '/LC_RPATH/{getline;getline;print $2}' || true)
            for rp in $rpaths; do
              if [[ "$rp" == /nix/store/* ]]; then
                install_name_tool -delete_rpath "$rp" "$file" 2>/dev/null || true
              fi
            done
          }

          process_file() {
            local file="$1"
            is_macho "$file" || return 0

            chmod u+w "$file" 2>/dev/null || true
            add_rpaths "$file"
            delete_nix_rpaths "$file"

            local deps
            deps=$(otool -L "$file" 2>/dev/null | tail -n +2 | awk "{print \$1}" || true)
            for dep in $deps; do
              case "$dep" in
                /nix/store/*|/usr/local/*|/opt/homebrew/*)
                  local target
                  target=$(copy_dep "$dep")
                  local newref
                  newref=$(newref_for_dep "$dep")
                  install_name_tool -change "$dep" "$newref" "$file" 2>/dev/null || true
                  [ -n "$target" ] && QUEUE+=("$target")
                  ;;
                *)
                  ;;
              esac
            done
          }

          QUEUE=()
          while IFS= read -r -d '' f; do QUEUE+=("$f"); done < <(find "$APP/Contents/MacOS" -type f -print0)
          while IFS= read -r -d '' f; do QUEUE+=("$f"); done < <(find "$FW_DIR" -type f -print0)
          if [ -d "$PLUGINS_DIR" ]; then
            while IFS= read -r -d '' f; do QUEUE+=("$f"); done < <(find "$PLUGINS_DIR" -type f -print0)
          fi

          SEEN_FILE=$(mktemp)
          while [ ${#QUEUE[@]} -gt 0 ]; do
            file="${QUEUE[0]}"
            QUEUE=("${QUEUE[@]:1}")
            if grep -Fxq "$file" "$SEEN_FILE"; then
              continue
            fi
            echo "$file" >> "$SEEN_FILE"
            process_file "$file"
          done
          rm -f "$SEEN_FILE"

          if [ -d "$FW_DIR" ]; then
            while IFS= read -r -d '' lib; do
              is_macho "$lib" || continue
              chmod u+w "$lib" 2>/dev/null || true
              rel="${lib#$FW_DIR/}"
              if [[ "$rel" == *.framework/* ]]; then
                install_name_tool -id "@rpath/$rel" "$lib" 2>/dev/null || true
              else
                install_name_tool -id "@rpath/$(basename "$lib")" "$lib" 2>/dev/null || true
              fi
            done < <(find "$FW_DIR" -type f -print0)
          fi

      - name: Install create-dmg
        run: brew install create-dmg
      - name: Codesign app bundle (ad-hoc)
        run: |
          codesign --force --deep --sign - "dist/tbc-tools.app"

      - name: Verify app bundle
        run: |
          echo "App bundle contents:"
          find dist/tbc-tools.app -type f | head -20
          if [ ! -d "dist/tbc-tools.app/Contents/_CodeSignature" ]; then
            echo "Missing _CodeSignature after codesign"
            exit 1
          fi
          echo "\nMain executable dependencies:"
          otool -L dist/tbc-tools.app/Contents/MacOS/ld-analyse 2>/dev/null | head -10 || echo "Could not check dependencies"
          echo "\nMain executable rpaths:"
          otool -l dist/tbc-tools.app/Contents/MacOS/ld-analyse | grep -A2 LC_RPATH || true
          if ! otool -l dist/tbc-tools.app/Contents/MacOS/ld-analyse | grep -q LC_RPATH; then
            echo "No LC_RPATH entries found in ld-analyse"
            exit 1
          fi
          echo "\nScanning for /nix/store references:"
          FOUND=0
          while IFS= read -r -d '' f; do
            if file "$f" 2>/dev/null | grep -q "Mach-O"; then
              if otool -L "$f" 2>/dev/null | grep -q "/nix/store"; then
                echo "Nix load refs in: $f"
                FOUND=1
              fi
              if otool -l "$f" 2>/dev/null | grep -q "/nix/store"; then
                echo "Nix rpath refs in: $f"
                FOUND=1
              fi
            fi
          done < <(find dist/tbc-tools.app -type f -print0)
          if [ "$FOUND" -ne 0 ]; then
            echo "Found /nix/store references in app bundle"
            exit 1
          fi

      - name: Create DMG
        run: |
          create-dmg \
            --volname "TBC Tools ${{ steps.version.outputs.version }}" \
            --volicon "dist/tbc-tools.app/Contents/Resources/tbc-tools.icns" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "tbc-tools.app" 200 190 \
            --hide-extension "tbc-tools.app" \
            --app-drop-link 600 190 \
            --skip-jenkins \
            --format UDBZ \
            "tbc-tools_${{ matrix.arch }}.dmg" \
            "dist/tbc-tools.app"

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: tbc-tools_macos_${{ matrix.arch }}
          path: tbc-tools_${{ matrix.arch }}.dmg
          if-no-files-found: error