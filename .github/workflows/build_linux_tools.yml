name: "Build Linux tools"

on:
  workflow_dispatch:
  release:
    types: [created]

env:
  APPIMAGE_FILE: "linuxdeploy-x86_64.AppImage"
  APPIMAGE_URL: "https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage"
  APPIMAGE_PLUGIN_FILE: "linuxdeploy-plugin-appimage-x86_64.AppImage"
  APPIMAGE_PLUGIN_URL: "https://github.com/linuxdeploy/linuxdeploy-plugin-appimage/releases/download/continuous/linuxdeploy-plugin-appimage-x86_64.AppImage"
  APPIMAGE_QT_FILE: "linuxdeploy-plugin-qt-x86_64.AppImage"
  APPIMAGE_QT_URL: "https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage"

jobs:
  build-tbc-tools:
    name: Build tbc-tools (x86_64)
    runs-on: ubuntu-latest
    container:
      image: oraclelinux:8
      options: --user 0 --cap-add SYS_ADMIN --cap-add MKNOD --device /dev/fuse:mrw --security-opt apparmor:unconfined --privileged

    steps:
      - name: Set up DNF download cache
        id: dnf-cache
        uses: actions/cache@v3
        with:
          path: /var/cache/dnf
          key: dnfcache
          
      - name: Setup environment
        run: |
          dnf install --assumeyes --nogpgcheck https://dl.fedoraproject.org/pub/epel/epel-release-latest-$(rpm -E %rhel).noarch.rpm
          dnf install --assumeyes --nogpgcheck https://mirrors.rpmfusion.org/free/el/rpmfusion-free-release-$(rpm -E %rhel).noarch.rpm https://mirrors.rpmfusion.org/nonfree/el/rpmfusion-nonfree-release-$(rpm -E %rhel).noarch.rpm
          FORCE_DNF=1 /usr/bin/crb enable
          dnf --assumeyes install sudo git file xz ca-certificates patchelf libglvnd-opengl libglvnd-glx libglvnd-egl fftw-devel ffmpeg-devel ffmpeg pkgconf-pkg-config make cmake gcc-c++
          update-ca-trust
          mkdir -p -m 0755 /nix
          chown root /nix
          groupadd --system nixbld || true
          for i in $(seq 1 32); do
            useradd --system --gid nixbld --groups nixbld --no-create-home --home-dir /var/empty --shell /sbin/nologin "nixbld$i" || true
          done

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: true

      - name: Install Nix
        shell: bash
        run: |
          curl -L https://nixos.org/nix/install | sh -s -- --no-daemon --yes
          echo "/nix/var/nix/profiles/default/bin" >> "$GITHUB_PATH"
          echo "/root/.nix-profile/bin" >> "$GITHUB_PATH"
          echo "$HOME/.nix-profile/bin" >> "$GITHUB_PATH"
          echo "NIX_CONFIG=experimental-features = nix-command flakes" >> "$GITHUB_ENV"
          echo "NIX_PATH=nixpkgs=channel:nixos-unstable" >> "$GITHUB_ENV"
          echo "NIX_SSL_CERT_FILE=/etc/pki/tls/certs/ca-bundle.crt" >> "$GITHUB_ENV"

      - name: Create release directory
        run: mkdir release/

      - name: Build with Nix
        run: |
          export HOME=/root
          export PATH="/nix/var/nix/profiles/default/bin:/root/.nix-profile/bin:$HOME/.nix-profile/bin:$PATH"
          chown -R "$(id -u):$(id -g)" "$GITHUB_WORKSPACE"
          nix build .#
          mkdir -p AppDir/usr/bin AppDir/usr/lib
          SKIP_LIB_REGEX='^(libc\.so\.6|libm\.so\.6|libpthread\.so\.0|libdl\.so\.2|librt\.so\.1|libresolv\.so\.2|ld-linux-.*\.so\..*|libnss_.*|libutil\.so\..*|libanl\.so\..*)$'
          for wrapped in result/bin/.*-wrapped; do
            [ -f "$wrapped" ] || continue
            base="$(basename "$wrapped")"
            base="${base#.}"
            base="${base%-wrapped}"
            cp -a "$wrapped" "AppDir/usr/bin/$base"
          done
          for item in result/bin/*; do
            [ -e "$item" ] || continue
            base="$(basename "$item")"
            [ -e "AppDir/usr/bin/$base" ] && continue
            cp -a "$item" "AppDir/usr/bin/$base"
          done
          cp -a result/lib/. AppDir/usr/lib/ || true
          LIBSTDCPP_PATH="$(ldd result/bin/.ld-analyse-wrapped | awk '$1 == "libstdc++.so.6" { print $3; exit }')"
          LIBGCC_PATH="$(ldd result/bin/.ld-analyse-wrapped | awk '$1 == "libgcc_s.so.1" { print $3; exit }')"
          [ -n "$LIBSTDCPP_PATH" ] && cp -L "$LIBSTDCPP_PATH" AppDir/usr/lib/libstdc++.so.6
          [ -n "$LIBGCC_PATH" ] && cp -L "$LIBGCC_PATH" AppDir/usr/lib/libgcc_s.so.1
          pending=1
          while [ "$pending" -eq 1 ]; do
            pending=0
            for elf in AppDir/usr/bin/* AppDir/usr/lib/*; do
              [ -f "$elf" ] || continue
              for dep in $(ldd "$elf" 2>/dev/null | awk '/=> \/nix\/store/ { print $3 }'); do
                [ -f "$dep" ] || continue
                base="$(basename "$dep")"
                if echo "$base" | grep -Eq "$SKIP_LIB_REGEX"; then
                  continue
                fi
                dest="AppDir/usr/lib/$base"
                if [ ! -e "$dest" ]; then
                  cp -L "$dep" "$dest"
                  pending=1
                fi
              done
            done
          done

      - name: Download linuxdeploy and build AppImage
        run: |
          curl -LJO ${{ env.APPIMAGE_URL }}
          curl -LJO ${{ env.APPIMAGE_PLUGIN_URL }}
          curl -LJO ${{ env.APPIMAGE_QT_URL }}

          chmod +x ${{ env.APPIMAGE_FILE }} ${{ env.APPIMAGE_PLUGIN_FILE }} ${{ env.APPIMAGE_QT_FILE }}
          export APPIMAGE_EXTRACT_AND_RUN=1
          SKIP_LIB_REGEX='^(libc\.so\.6|libm\.so\.6|libpthread\.so\.0|libdl\.so\.2|librt\.so\.1|libresolv\.so\.2|ld-linux-.*\.so\..*|libnss_.*|libutil\.so\..*|libanl\.so\..*)$'
          QMAKE="$(find /nix/store -type f -path '*/bin/qmake' | sort | head -n 1 || true)"
          if [ -z "$QMAKE" ]; then
            QMAKE="$(find /nix/store -type f -path '*/bin/qmake6' | sort | head -n 1 || true)"
          fi
          if [ -n "$QMAKE" ]; then
            export QMAKE
            export PATH="$(dirname "$QMAKE"):$PATH"
          fi

          EXTRA_QT_MODULES="core;gui;opengl;widgets;sql" ./${{ env.APPIMAGE_QT_FILE }} --appdir AppDir

          # Ensure SVG icon support is bundled (toolbar icons in ld-analyse are SVG resources)
          copy_qt_plugin() {
            plugin_rel="$1"
            plugin_src="$(find /nix/store -type f -path "*/plugins/${plugin_rel}" | sort | head -n 1 || true)"
            if [ -z "$plugin_src" ]; then
              echo "Required Qt plugin missing from Nix store: ${plugin_rel}"
              exit 1
            fi
            mkdir -p "AppDir/usr/plugins/$(dirname "$plugin_rel")"
            cp -L "$plugin_src" "AppDir/usr/plugins/${plugin_rel}"
            echo "Bundled Qt plugin: ${plugin_rel} <- ${plugin_src}"
          }

          copy_qt_plugin "iconengines/libqsvgicon.so"
          copy_qt_plugin "imageformats/libqsvg.so"
          pending=1
          while [ "$pending" -eq 1 ]; do
            pending=0
            for elf in AppDir/usr/plugins/*/*.so AppDir/usr/lib/*.so*; do
              [ -f "$elf" ] || continue
              for dep in $(ldd "$elf" 2>/dev/null | awk '/=> \// { print $3 }'); do
                [ -f "$dep" ] || continue
                base="$(basename "$dep")"
                if echo "$base" | grep -Eq "$SKIP_LIB_REGEX"; then
                  continue
                fi
                dest="AppDir/usr/lib/$base"
                if [ ! -e "$dest" ]; then
                  cp -L "$dep" "$dest"
                  pending=1
                fi
              done
            done
          done

          # Create minimal desktop file
          mkdir -p AppDir/usr/share/applications
          cat > AppDir/usr/share/applications/tbc-tools.desktop << EOF
          [Desktop Entry]
          Type=Application
          Name=TBC Tools
          Comment=Time Base Corrected video analysis tools
          Exec=ld-analyse
          Icon=tbc-tools
          Categories=AudioVideo;Video;
          EOF
          # Provide application icon for desktop entry
          mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
          cp src/ld-analyse/Graphics/256-analyse.png AppDir/usr/share/icons/hicolor/256x256/apps/tbc-tools.png

          ./${{ env.APPIMAGE_FILE }} \
          --desktop-file AppDir/usr/share/applications/tbc-tools.desktop \
          --icon-file AppDir/usr/share/icons/hicolor/256x256/apps/tbc-tools.png \
          --appdir AppDir/ \
          --output appimage
          APPIMAGE_OUT="$(find . -maxdepth 1 -type f -name '*.AppImage' ! -name 'linuxdeploy*.AppImage' | sort | head -n 1)"
          if [ -z "$APPIMAGE_OUT" ]; then
            echo "No generated AppImage found in workspace root"
            ls -1 *.AppImage || true
            exit 1
          fi
          cp "$APPIMAGE_OUT" release/tbc-tools-x86_64.AppImage

      - name: Copy scripts
        run: find scripts -maxdepth 1 -type f -executable -exec cp {} release/ \; || true

      - name: Create release archive
        run: tar -cvJSf tbc-tools_linux_x86_64.tar.xz --transform s/release/tbc-tools/ release/

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: tbc-tools_linux_x86_64
          path: tbc-tools_linux_x86_64.tar.xz
          if-no-files-found: error
  build-tbc-tools-arm64:
    name: Build tbc-tools (arm64)
    runs-on: ubuntu-24.04-arm

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          submodules: true

      - name: Install Nix
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable

      - name: Create release directory
        run: mkdir -p release/bin release/lib

      - name: Build with Nix
        run: |
          nix build .#
          SKIP_LIB_REGEX='^(libc\.so\.6|libm\.so\.6|libpthread\.so\.0|libdl\.so\.2|librt\.so\.1|libresolv\.so\.2|ld-linux-.*\.so\..*|libnss_.*|libutil\.so\..*|libanl\.so\..*)$'
          for wrapped in result/bin/.*-wrapped; do
            [ -f "$wrapped" ] || continue
            base="$(basename "$wrapped")"
            base="${base#.}"
            base="${base%-wrapped}"
            cp -a "$wrapped" "release/bin/$base"
          done
          for item in result/bin/*; do
            [ -e "$item" ] || continue
            base="$(basename "$item")"
            [ -e "release/bin/$base" ] && continue
            cp -a "$item" "release/bin/$base"
          done
          cp -a result/lib/. release/lib/ || true
          LIBSTDCPP_PATH="$(ldd result/bin/.ld-analyse-wrapped | awk '$1 == "libstdc++.so.6" { print $3; exit }')"
          LIBGCC_PATH="$(ldd result/bin/.ld-analyse-wrapped | awk '$1 == "libgcc_s.so.1" { print $3; exit }')"
          [ -n "$LIBSTDCPP_PATH" ] && cp -L "$LIBSTDCPP_PATH" release/lib/libstdc++.so.6
          [ -n "$LIBGCC_PATH" ] && cp -L "$LIBGCC_PATH" release/lib/libgcc_s.so.1
          pending=1
          while [ "$pending" -eq 1 ]; do
            pending=0
            for elf in release/bin/* release/lib/*; do
              [ -f "$elf" ] || continue
              for dep in $(ldd "$elf" 2>/dev/null | awk '/=> \/nix\/store/ { print $3 }'); do
                [ -f "$dep" ] || continue
                base="$(basename "$dep")"
                if echo "$base" | grep -Eq "$SKIP_LIB_REGEX"; then
                  continue
                fi
                dest="release/lib/$base"
                if [ ! -e "$dest" ]; then
                  cp -L "$dep" "$dest"
                  pending=1
                fi
              done
            done
          done

      - name: Copy scripts
        run: find scripts -maxdepth 1 -type f -executable -exec cp {} release/ \; || true

      - name: Create release archive
        run: tar -cvJf tbc-tools_linux_arm64.tar.xz --transform s/release/tbc-tools/ release/

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: tbc-tools_linux_arm64
          path: tbc-tools_linux_arm64.tar.xz
          if-no-files-found: error
